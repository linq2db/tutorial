---
title: Введение
---

# Введение

## Описание курса

По завершению данного курса вы сможете свободно использовать linq2db для доступа к базам данных, строить простые и иногда не очень SQL запросы.

Для прочтения курса вам необходимы следующие знания:
* Базовые знания C#.
* Базовые знания SQL.
* Понимание задач, встающих перед [ORM](https://ru.wikipedia.org/wiki/ORM). Если вы не в курсе что такое ORM  и зачем они нужны, рекомендую прочитать главу "Объектные модели и реляционные базы данных" из книги М. Фаулера "Шаблоны корпоративных приложений".
* Базовые знания [LINQ](https://docs.microsoft.com/ru-ru/dotnet/csharp/linq/)
* В принципе, не плохо бы знать что такое ADO .Net, но если вы этого не знаете, то по завершению данного курса оно вам больше и не понадобиться... ну почти :)

## Как построен курс

Курс состоит из двух частей - теоретической и практической. В рамках теоретической части мы рассмотрим как использовать linq2db для общения с базой данных. В рамках практического курса мы напишем небольшое приложение, реализующее бонусную систему для сети магазинов "Ромашка". 

Практическая часть будет завершающей к каждой главе. Исходные коды доступны в [репозитории](https://github.com/linq2db/tutorial.sources), каждый раздел выведен в отдельную ветку.

## Общие сведения по linq2db

На текущее время на рынке существует множество ORM для .Net:

* [Dapper](https://github.com/StackExchange/Dapper)
* [Entity Framework](https://docs.microsoft.com/ru-ru/ef/)
* [NHibernate](https://nhibernate.info/)
* [И так далее](https://www.google.com/search?q=.net%20orm)

Так почему же мы выбираем linq2db? И что выделяет данную библиотеку среди прочих? Давайте разберем данный вопрос по порядку.

1. Скорость. Построение и материализация (т.е. маппинг данных из [IDataReader](https://docs.microsoft.com/ru-ru/dotnet/api/system.data.idatareader?view=netcore-2.1) в объекты) запросов одно из быстрейших на рынке. Этот показатель крайне важен для высоконагруженных систем, в особенности когда речь идет о трехзвенной архитектуре.
1. Типобезопасность. Отсутствие необходимости писать SQL запросы текстом увеличивает скорость разработки и надежность приложений. Формируя LINQ запрос мы точно знаем какие типы у нас будут на выходе, и как следствие мы защищены от целого спектра проблем уже на уровне компилятора.
1. Широкий спектр без данных. linq2db поддерживает **все** основные базы данных (MS SQL Server, Oracle, MySQL, Postgres [и так далее](https://linq2db.github.io/articles/general/databases.html)), и даже больше ([SAP HANA](https://www.nuget.org/packages/linq2db.SapHana/), например).
1. SQL First - сначала качественный SQL потом всё остальное. Детальнее мы поговорим об этом чуть ниже, пока же остановимся на том, что у linq2db **самая** широкая поддержка SQL из всех решений на рынке.
1. Генерация модели данных из базы. Это важный аспект, который с одной стороны вытекает из предыдущего пункта, с другой снимает с вас необходимость описывать модели (POCO) руками.
1. Надежность. Несколько **тысяч** тестов для **всех** поддерживаемых баз данных. С linq2db у вас отпадает необходимость писать тесты на запросы к данным (Data Access Layer).

## Как это работает

### Коротко

`LINQ-SQL-POCO` - из LINQ запроса строится SQL запрос, который отправляется на сторону БД, результат выборки мапится на ваш POCO.

### Длинно

LINQ - поддерживает возможность писать не запросы а [AST](https://ru.wikipedia.org/wiki/%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D0%BE%D0%B5_%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE), приглядевшись внимательнее вы увидите что многие LINQ методы принимают не только функции, но и [выражения](https://docs.microsoft.com/ru-ru/dotnet/csharp/programming-guide/concepts/expression-trees/). Скажем метод `Where` есть в двух сигнатурах:

[Для IEnumerable](https://docs.microsoft.com/ru-ru/dotnet/api/system.linq.enumerable.where)

```cs
Where<TSource>(IEnumerable<TSource>, Func<TSource,Boolean>)
```

и [для IQuerable](https://docs.microsoft.com/ru-ru/dotnet/api/system.linq.queryable.where)

```cs
Where<TSource>(IQueryable<TSource>, Expression<Func<TSource,Boolean>>)
```

Второй метод как раз и получает AST, и именно методы для `IQueryable<T>` и использует linq2db. C# же "прячет" этот нюанс от разработчиков и чисто визуально мы не видим никакой разницы между обращением к первому и второму методу.

Итак, делая LINQ запрос к `IQueryable<T>` мы получаем не цепочку вызова методов, а AST этого самого запроса. Ну а раз у нас есть AST, значит из него можно построить всё что душе угодно, в том числе и SQL запрос. Именно это и делает linq2db.

Затем полученный запрос выполняется на сервере используя механизмы, предоставляемые [ADO .Net](https://docs.microsoft.com/ru-ru/dotnet/framework/data/adonet/).

Результат же запроса, преобразуется к POCO объекту маппером, сгенерированным linq2db, по тому же AST что и запрос (кстати, именно этот момент обеспечивает высокую скорость материализации у linq2db).

## Философия SQL First

Очень часто можно встретить мнение, что раз у нас есть ORM то разработчику вовсе и не нужно заморачиваться за знание SQL, ведь всё одно ORM его полностью изолирует от базы данных и необходимости писать запрос руками. Так вот, linq2db считает такой подход, мягко говоря, некорректным.

SQL - прекраснейший и мощнейший инструмент разработчика, и лучше него для работы с реляционными базами данных ничего ещё не придумали. Отбирать его у программиста, всё равно что забрать сварочный аппарат у сварщика. Единственный его недостаток - отсутствие типобезопасности, порожденное необходимостью писать SQL запрос текстом и отправлять его на сервер. В общем-то большинство ORM и решают эту проблему, генерируя запросы автоматически, тем же, по сути, занимается и linq2db, но тут есть очень важный момент - в случае если linq2db не сможет преобразовать LINQ запрос в SQL запрос мы получим ошибку в рантайме, и это - **хорошо**. Многие ORM системы в подобном случае автоматически "упрощают" запрос, выполняют его на БД, затем материализуют результат и прогоняют его далее через обычный LINQ. Здесь, вы можете сказать "ну и что вам не нравится, мы же получили ровно тот результат, который и ожидали, программа работает корректно, расходимся", и да, вы будете правы, но какой ценой? Давайте представим что мы строим годовой отчет по продажам газированной воды с красной этикеткой, конечно же мы хотим видеть итоговые суммы, сгруппированные, скажем, по кварталам и странам. Программист пишет LINQ запрос, а ORM его выполняет, но тут выясняется что запрос оказался слишком сложным, и ORM не справилась с задачей построения группировки по двум полям. "Не беда!", решает ORM - запрошу ка я **все** данные на сервере а потом тихонечко сделаю группировку здесь у себя. Как следствие мы получим на клиенте (в программе) миллионы записей, которые потом будут группироваться на этом же клиенте. Да, результат тут будет таким же как если бы это всё произошло на стороне БД, но вот только БД выполнила бы это действие в разы быстрее и экономнее. А ведь может и так случиться, что перед большим совещанием по итогам года, все боссы решат поглядеть этот отчет, и тут, скорее всего, уже что то сломается и кому-то достанется...

Выбрав linq2db вы в первую голову принимаете решение, что "SQL важнее". По сути правильно оценивать linq2db не как ORM, а как способ писать SQL запросы на C#.

[Далее](nuget.md)
