---
title: Управление соединением
---

# Управление соединением

Для выполнения запроса на стороне БД необходимо установить с ней соединение. `linq2db` предоставляет два основных класса для управления соединениями (конкретные различия между ними мы рассмотрим ниже в разделе "Время жизни соединения"):

* [DataConnection](https://linq2db.github.io/api/LinqToDB.Data.DataConnection.html)
* [DataContext](https://linq2db.github.io/api/LinqToDB.DataContext.html)

Рассмотрим пример выполнения запроса, на выборе всех записей из таблицы:

```cs
// Создадим соединения
using (var db = new DataConnection())
{
    // Создадим объект для выполнения запроса
    IQueryable<Customer> customersTable = db.GetTable<Customer>();

    // Выполним запрос
    Customer[] customers = customersTable.ToArray();

    // Выведем результаты запроса
    foreach (var c in customers)
        Console.WriteLine($"{c.FullName}: {c.Phone}");
}
```

Остановимся подробнее на создании объекта для выполнения запроса: `db.GetTable<Customer>()`. Во введении мы рассматривали две перегрузки для LINQ метода `Where`: один для `IEnumerable<T>` другой для `IQueryable<T>`, именно второй получал в качестве аргумента выражение а не функцию. Что бы построить SQL запрос, нам нужны именно методы получающие выражения, т.е. перегрузки, использующие `IQueryable<T>`. Метод расширения [GetTable](https://linq2db.github.io/api/LinqToDB.DataExtensions.html#LinqToDB_DataExtensions_GetTable__1_LinqToDB_IDataContext_) создает объект для которого возможно построение SQL запроса.

LINQ является "ленивым", и запрос будет выполнен только при обращении к его результатам:

* При перечислении запроса с использованием `foreach`.
* При вызове одного из методов материализации запроса: `ToArray`, `ToList`, `ToDictionary`, и т.д.
* При получении результата асинхронных перегрузок методов материализации: `await qry.ToArrayAsync()`, `await qry.ToListAsync()`, `await qry.ToDictionaryAsync()`, выполнение происходит именно при использовании ключевого слова `await`.

Знание и понимание этих нюансов важно при построении сложных запросов, а именно:

* Там где вы выполняете операции над `IQueryable<T>` будет создан и выполнен на стороне сервера SQL.
* Там где вы выполняете операции над `IEnumerable<T>` вся обработка будет происходить на стороне вашего приложения.

Рассмотри два примера с выполнением запроса на стороне сервера и клиента.

```cs
// Создадим соединения
using (var db = new DataConnection())
{
    // Создадим объект для выполнения запроса
    IQueryable<Customer> customersTable = db.GetTable<Customer>();

    // Выполним запрос на стороне сервера
    Customer[] customers = customersTable
        .Where(_ => _.FullName == "Иванов Иван Иванович")
        .ToArray();

    // Выведем результаты запроса
    foreach (var c in customers)
        Console.WriteLine($"{c.FullName}: {c.Phone}");
}
```

В данном случае будет построен и выполнен запрос:

```sql
SELECT
    Id,
    FullName,
    Phone
FROM Customer
WHERE FullName = 'Иванов Иван Иванович'
```

Теперь слегка модифицируем наш код:

```cs
// Создадим соединения
using (var db = new DataConnection())
{
    // Создадим объект для выполнения запроса
    IEnumerable<Customer> customersTable = db.GetTable<Customer>().AsEnumerable();

    // Выполним запрос
    Customer[] customers = customersTable
        .Where(_ => _.FullName == "Иванов Иван Иванович")
        .ToArray();

    // Выведем результаты запроса
    foreach (var c in customers)
        Console.WriteLine($"{c.FullName}: {c.Phone}");
}
```

В данном случае будет построен и выполнен следующий запрос:
```sql
SELECT
    Id,
    FullName,
    Phone
FROM Customer
```

Т.е. с сервера будут забраны **все** записи таблицы `Customer` а фильтрация произойдет уже в программе (на стороне клиента).

## Время жизни соединения

Одним из наиболее важных моментов является управление временем жизни соединения. Поскольку открытие соединения в БД является дорогостоящей операцией .Net провайдеры используют пулл соединений для минимизации издержек: соединение берется из пулла, используется для выполнения запроса, после чего оно должно быть высвобождено для возвращения обратно в пулл с целью обеспечения возможности повторного использования.

Если соединения не высвобождать, то произойдет следующее:

* Приложение будет постоянно создавать новые соединения с БД, т.к. с точки зрения пулла не будет свободных соединений, которые можно повторно использовать.
* В конце концов будет достигнут лимит соединений в пулле, что приведет к невозможности создания новых соединений, и, как следствие, невозможности выполнения запросов к БД.

Данная ситуация называется "утечкой соединений".

Для того, что бы избежать утечки соединений их **необходимо** высвобождать по завершению работы, собственно именно по способу высвобождения отличаются `DataConnection` и `DataContext`:

* `DataConnection` - использует одно соединение для выполнения нескольких запросоав к БД. Это позволяет минимизировать издержки на открытие соединений с одной стороны, и выполнять несколько запросов в одной транзакции с другой. При использовании данного класса следует выполнять простые правила:
  * **Всегда** вызывайте метод `DataConnection.Dispose()` после выполнения запросов рекомендуется использовать для этого блок `using`.
  * Запрос должен быть выполнен **до** вызова `DataConnection.Dispose()`.
* `DataContext` - открывает и закрывает соединение для **каждого** запроса. С одной стороны это минимизирует шансы утечки соединения, с другой это неэффективно при выполнении нескольких запросов подряд и не позволяет использовать транзакции.

Рассмотрим примеры правильного и неправильного управления временем жизни соединения.

### Правильно

```cs
using (var db = new DataConnection())
{
// Здесь должен быть ваш код
}

public IEnumerable<Person> GetPersons()
{
    using (var db = new DataConnection())
    {
        // ToList выполняет запрос пока мы находимся внутри блока using
        return db.GetTable<Person>().ToList();
    }
}

public IEnumerable<Person> GetPersons()
{
    // ToList выполняет запрос, DataContext автоматически открывает и закрывает соединение
    return new DataContext().GetTable<Person>().ToList();
}

public async Task<IEnumerable<Person>> GetPersons()
{
    using (var db = new DataConnection())
    {
        // В данном примере await ожидает выполнения асинхронного запроса,
        // после выполнения ToListAsync() результат будет возвращен вызывающему методу,
        // а DataConnection будет корректно высвобожден блоком using
        return await db.GetTable<Person>().ToListAsync(); 
    }
}

```

### Неправильно

```cs
public IEnumerable<Person> GetPersons()
{
    using (var db = new DataConnection())
    {
        // В данном примере запрос будет выполнен только в тот момент,
        // когда начнется перечисление его результатов,
        // однако, к этому моменту соединение уже будет высвобождено
        // блоком using, и как следствие при выполнении запроса
        // будет выброшен ObjectDisposedException
        return db.GetTable<Person>();
    }
}

// Здесь произойдет ObjectDisposedException
var persons = GetPersons().ToList();
```

```cs
public async Task<IEnumerable<Person>> GetPersons()
{
    using (var db = new DataConnection())
    {
        // В данном случае управление немедленно вернется вызывающему коду,
        // без ожидания завершения выполнения запроса,
        // после чего объект соединения будет высвобожден
        return db.GetTable<Person>().ToListAsync();
    }
}

// Здесь произойдет выполнение запроса, но соединение уже будет закрыто
// и мы получим ObjectDisposedException
var persons = await GetPersons();
```

## Многопоточность

Объект соединения не является многопоточным (в первую голову это продиктовано ADO .Net), и означает это следующее:<br/>
**нельзя одновременно выполнить два запроса на одном соединении**<br/>
при попытке выполнить несколько запросов вы получите исключение на уровне используемого ADO .Net клиента.

## Далее

[Настройка соединения](connectionsettings.md)
